# STEP 1: Webcam Capture

from IPython.display import Javascript, display
from google.colab.output import eval_js
from base64 import b64decode
import cv2, io, time
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

def take_photo():
    js_code = Javascript('''
      async function snapshot(){
        const video = document.createElement('video');
        const stream = await navigator.mediaDevices.getUserMedia({video: true});
        document.body.appendChild(video);
        video.srcObject = stream;
        await video.play();

        // Let camera settle
        await new Promise(resolve => setTimeout(resolve, 800));

        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);

        stream.getTracks()[0].stop();
        video.remove();

        return canvas.toDataURL('image/jpeg', 0.9);
      }
    ''')
    display(js_code)
    data = eval_js("snapshot()")
    binary = b64decode(data.split(',')[1])
    return np.array(Image.open(io.BytesIO(binary)))


# STEP 2: Calibration Parameters

board_size = (9, 6)       # inner chessboard corners
square_len = 25.0         # mm size of each square
num_images = 12           # capture target

# Generate 3D reference points for corners
obj_template = np.zeros((board_size[0]*board_size[1], 3), np.float32)
obj_template[:, :2] = np.mgrid[0:board_size[0], 0:board_size[1]].T.reshape(-1, 2)
obj_template *= square_len

object_points = []   # 3D points in real world
image_points = []    # 2D points in image plane
img_size = None

# STEP 3: Image Capture Loop

print("Show the Chessboard Towards the Camera")

for idx in range(num_images):
    photo = take_photo()
    frame = cv2.cvtColor(photo, cv2.COLOR_RGB2BGR)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    if img_size is None:
        img_size = gray.shape[::-1]

    found, corners = cv2.findChessboardCorners(gray, board_size, None)

    if found:
        refined = cv2.cornerSubPix(
            gray, corners, (11, 11), (-1, -1),
            (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 40, 0.001)
        )
        object_points.append(obj_template)
        image_points.append(refined)

        # Draw and display
        cv2.drawChessboardCorners(frame, board_size, refined, found)
        plt.imshow(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
        plt.axis("off")
        plt.show()

        print(f"Captured {idx+1}/{num_images}")
        time.sleep(1)
    else:
        print("Chessboard not detected")
        time.sleep(1)


# STEP 4: Run Calibration

if object_points and image_points:
    ret, K, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(
        object_points, image_points, img_size, None, None
    )

    print("\n Camera Matrix (K):\n", K)
    print("\n Distortion Coefficients:\n", dist_coeffs.ravel())

    fx, fy = K[0, 0], K[1, 1]
    cx, cy = K[0, 2], K[1, 2]

    print(f"\n Focal Lengths: fx = {fx:.2f}, fy = {fy:.2f}")
    print(f" Principal Point: cx = {cx:.2f}, cy = {cy:.2f}")
else:
    print("Calibration failed. No valid chessboard detections.")
